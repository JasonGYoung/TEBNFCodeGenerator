/**
 * @see Utils.hpp
 */

//Primary include:
#include "Utils.hpp"

//Local includes:
#include "../Nodes/CppTypeInfo.hpp"
#include "../Nodes/Elements.hpp"

//System includes:
#include <cfloat>
#include <climits>
#include <ctime>
#include <iomanip>

std::string Utils::getDateTimeAsString()
{
  time_t rawtime;
  time(&rawtime);
  struct tm timeinfo;
  localtime_s(&timeinfo, &rawtime);
  std::stringstream s;
  s << std::put_time(&timeinfo, "%d-%m-%Y %H:%M:%S");
  return s.str();
}

std::string Utils::getClassPrefaceComment(const std::string& fileName,
                                          const std::string& description)
{
  std::stringstream s;
  s << "/*\n"
    << " *******************************************************************************\n"
    << " * Generated by TEBNF Code Generator v" << Utils::getTEBNFVersion() << " @ " << Utils::getDateTimeAsString() << "\n"
    << " * File name:   " << fileName << "\n"
    << " * Author:      Jason Young\n";
  if(!description.empty())
  {
    std::string descriptionFormatted(description);
    if(description.length() > 65)
    {
      int i = 0;
      auto it = descriptionFormatted.begin();
      while(it != descriptionFormatted.end())
      {
        if(i != 0 && 0 == i % 65)
        {
          int j = i;
          while(j > 0 && !std::isspace(*it))
          {
            --it;
            --j;
          }
          std::string newLine("\n *             ");
          it = descriptionFormatted.insert(it, newLine.begin(), newLine.end());
          for(; j != i; j++)
            ++it;
        }
        ++i;
        ++it;
      }
    }
    s << " * Description: " << descriptionFormatted << "\n";
  }
  s << " *******************************************************************************\n"
    << " */\n";
  return s.str();
}

void Utils::trim(std::string& rStr)
{
  rStr.erase(rStr.begin(), std::find_if(rStr.begin(), rStr.end(),
    [](char& ch)->bool { return !isspace(ch); }));
  rStr.erase(std::find_if(rStr.rbegin(), rStr.rend(),
    [](char& ch)->bool { return !isspace(ch); }).base(), rStr.end());
}

std::string Utils::trimCopy(const std::string& str)
{
  std::string retStr(str);
  trim(retStr);
  return retStr;
}

void Utils::toLower(std::string& rStr)
{
  std::transform(rStr.begin(), rStr.end(), rStr.begin(), std::tolower);
}

std::string Utils::toLowerCopy(const std::string& str)
{
  std::string retStr(str);
  toLower(retStr);
  return retStr;
}

void Utils::toUpper(std::string& rStr)
{
  std::transform(rStr.begin(), rStr.end(), rStr.begin(), std::toupper);
}

std::string Utils::toUpperCopy(const std::string& str)
{
  std::string retStr(str);
  toUpper(retStr);
  return retStr;
}

namespace
{
  static std::set<std::string> m_cppVarNameAccessedElementNames;
}

std::string Utils::getCppVarName(const std::string& varName)
{
  std::string cppVarName(varName);
  if(!varName.empty())
  {
    if('@' == varName[0])
    {
      cppVarName = varName.substr(1);
      m_cppVarNameAccessedElementNames.insert(cppVarName);
    }
    else if(Elements::findElement("@" + varName)) //KLUDGE?: need to decide if '@' should be removed before setting in cppTypeInfo
    {
      m_cppVarNameAccessedElementNames.insert(cppVarName);
    }
    if('$' == varName[0])
      cppVarName = "s_" + varName.substr(1);
  }
  return trimCopy(cppVarName);
}

std::string Utils::getCppVarName(std::shared_ptr<Token> pToken, bool typeQualify)
{
  if(typeQualify && pToken->pAccessedElementToken)
  {
    auto pElem = Elements::findElement(pToken->pAccessedElementToken->text);
    auto cppVarName = getCppVarName(pToken->pAccessedElementToken->text);
    m_cppVarNameAccessedElementNames.insert(cppVarName);
    return cppVarName + pElem->getMemberAccessor() + getCppVarName(pToken->text);
  }
  return getCppVarName(pToken->text);
}

std::string Utils::getCppVarName(const CppTypeInfo& cppInfo, bool typeQualify)
{
  return cppInfo.pCppTypeNode &&
         cppInfo.pCppTypeNode->getToken()->pAccessedElementToken &&
         cppInfo.pCppTypeNode->getToken()->pAccessedElementToken->isSymbolElementNameAccessed() ?
    getCppVarName(cppInfo.pCppTypeNode->getToken(), typeQualify) :
    getCppVarName(cppInfo.typeNameStr);
}

std::string Utils::getCppVarName(std::shared_ptr<CppTypeInfo> pCppInfo, bool typeQualify)
{
  return getCppVarName(*pCppInfo, typeQualify);
}

std::string Utils::getElementAccessor(const CppTypeInfo& cppInfo)
{
  if(cppInfo.pCppTypeNode)
  {
    auto pAccessedElementTok = cppInfo.pCppTypeNode->getToken()->pAccessedElementToken;
    if(pAccessedElementTok && pAccessedElementTok->isSymbolElementNameAccessed())
    {
      auto pElem = Elements::findElement(pAccessedElementTok->text);
      auto cppVarName = getCppVarName(pAccessedElementTok->text);
      m_cppVarNameAccessedElementNames.insert(cppVarName);
      return cppVarName + pElem->getMemberAccessor();
    }
  }
  std::string cppTypeName(cppInfo.typeNameStr);
  auto pElem = '@' == cppTypeName[0] ?
    Elements::findElement(cppTypeName) :
    Elements::findElement("@" + cppTypeName);
  if('@' == cppTypeName[0])
    cppTypeName = cppTypeName.substr(1);
  m_cppVarNameAccessedElementNames.insert(cppTypeName);
  return pElem ?
    cppTypeName + pElem->getMemberAccessor() :
    cppTypeName + ".";
}

std::string Utils::getElementAccessor(std::shared_ptr<Element> pElement)
{
  if(pElement->getCppTypeInfo())
    return getElementAccessor(*pElement->getCppTypeInfo());
  auto pElem = Elements::findElement(pElement->getToken()->text);
  if(pElem && pElem->getCppTypeInfo())
    return getElementAccessor(*pElem->getCppTypeInfo());
  auto cppVarName = getCppVarName(pElement->getToken()->text);
  m_cppVarNameAccessedElementNames.insert(cppVarName);
  return cppVarName + pElem->getMemberAccessor();
}

void Utils::resetCppVarNameAccessedElementNames()
{
  m_cppVarNameAccessedElementNames.clear();
}

std::vector<std::string> Utils::getCppVarNameAccessedElementNames(bool reset)
{
  std::vector<std::string> ret;
  std::for_each(m_cppVarNameAccessedElementNames.begin(),
    m_cppVarNameAccessedElementNames.end(),
    [&](std::string name) { ret.push_back(name); });
  if(reset)
    Utils::resetCppVarNameAccessedElementNames();
  return ret;
}

float Utils::stof(const std::string& str, float defaultVal)
{
  try
  {
    return std::stof(str);
  }
  catch(const std::invalid_argument&)
  {
    return defaultVal;
  }
}

double Utils::stod(const std::string& str, double defaultVal)
{
  try
  {
    return std::stod(str);
  }
  catch(const std::invalid_argument&)
  {
    return defaultVal;
  }
}

long double Utils::stold(const std::string& str, long double defaultVal)
{
  try
  {
    return std::stold(str);
  }
  catch(const std::invalid_argument&)
  {
    return defaultVal;
  }
}


int Utils::stoi(const std::string& str, int base, int defaultVal)
{
  try
  {
    return std::stoi(str, 0, base);
  }
  catch(const std::invalid_argument&)
  {
    return defaultVal;
  }
}

long Utils::stol(const std::string& str, int base, long defaultVal)
{
  try
  {
    return std::stol(str, 0, base);
  }
  catch(const std::invalid_argument&)
  {
    return defaultVal;
  }
}

long long Utils::stoll(const std::string& str, int base, long long defaultVal)
{
  try
  {
    return std::stoll(str, 0, base);
  }
  catch(const std::invalid_argument&)
  {
    return defaultVal;
  }
}

